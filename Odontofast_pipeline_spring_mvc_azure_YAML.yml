# Trigger: Define quando a pipeline será automaticamente executada
trigger:
  branches:
    include:
    - main
    - master
    - minharelease
 
# Pool: Define o ambiente de execução da pipeline
pool:
  vmImage: "ubuntu-latest"
 
# Variáveis globais usadas em toda a pipeline
variables:
- name: rm553528
  value: rm553528
- name: location
  value: eastus
- name: resourceGroup
  value: rg-OdontofastPipeline553528
- name: service-plan
  value: planOdontofastPipeline553528
- name: app-name
  value: OdontofastPipeline-rm553528
- name: runtime
  value: JAVA:17-java17
- name: sku
  value: F1
- name: nome-artefato
  value: OdontofastPipelinerm553528
# Variáveis para SQL Server - seguindo o padrão do seu script anterior
- name: sql-server-name
  value: serversql-odontofast-rm553528
- name: sql-db-name
  value: database-odontofast-rm553528
- name: sql-admin-user
  value: sqladmin
- name: sql-admin-password
  value: Fiap@2tds2025
 
# Estágio 1: Criar a infraestrutura na Azure
stages:
- stage: CriarInfra
  jobs:
  - job: criaWebApp
    displayName: Criar ou atualizar o Serviço de Aplicativo
    steps:
    - task: AzureCLI@2
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Criar o Grupo de Recursos
          echo "Criando grupo de recursos..."
          az group create --location $(location) --name $(resourceGroup)
          # Criar o Plano de Serviço com SO igual a Linux
          echo "Criando plano de serviço..."
          az appservice plan create -g $(resourceGroup) -n $(service-plan) --is-linux --sku $(sku)
          # Criar um Serviço de Aplicativo com JAVA 17 SE como runtime
          echo "Criando App Service..."
          az webapp create -g $(resourceGroup) -p $(service-plan) -n $(app-name) --runtime "$(runtime)"
          # Verificar e excluir servidor SQL anterior, se existir
          echo "Verificando servidores SQL existentes..."
          if az sql server show --name $(sql-server-name) --resource-group $(resourceGroup) > /dev/null 2>&1; then
            echo "SQL Server com mesmo nome já existe. Excluindo..."
            az sql server delete --name $(sql-server-name) --resource-group $(resourceGroup) --yes
            # Aguardar para garantir que a exclusão seja concluída
            sleep 30
          fi
          # Criar SQL Server na eastus2 (seguindo exemplo que funcionou)
          echo "Criando SQL Server em eastus2..."
          az sql server create --resource-group $(resourceGroup) --name $(sql-server-name) --location eastus2 --admin-user $(sql-admin-user) --admin-password "$(sql-admin-password)"
          # Criar banco de dados com nível S0 (como no exemplo que funcionou)
          echo "Criando banco de dados com nível S0..."
          az sql db create --resource-group $(resourceGroup) --server $(sql-server-name) --name $(sql-db-name) --service-objective S0
          # Configurar regra de firewall para permitir serviços Azure
          echo "Configurando regras de firewall..."
          az sql server firewall-rule create --name AllowAzureServices \
            --resource-group $(resourceGroup) --server $(sql-server-name) \
            --start-ip-address 0.0.0.0 --end-ip-address 0.0.0.0
        visibleAzLogin: false
 
# Estágio 2: Build da aplicação Java
- stage: BuildApp
  variables:
  - name: mavenPOMFile
    value: 'pom.xml'
  jobs:
  - job: buildWebApp
    displayName: Realizar o Build do App
    steps:
    # Diagnóstico pré-build para confirmar estrutura do diretório
    - bash: |
        echo "Listando arquivos no diretório atual:"
        ls -la
        echo "Verificando se o pom.xml existe:"
        if [ -f $(mavenPOMFile) ]; then
          echo "O arquivo pom.xml foi encontrado!"
        else
          echo "ERRO: pom.xml não encontrado!"
        fi
      displayName: 'Diagnóstico pré-build'
      
    # Task de Maven atualizada para pular testes
    - task: Maven@3
      displayName: 'Build OdontofastPipeline'
      inputs:
        mavenPomFile: '$(mavenPOMFile)'
        goals: 'clean package'
        options: '-DskipTests'
        javaHomeOption: 'JDKVersion'
        jdkVersionOption: '1.17'
        publishJUnitResults: false
      
    # Diagnóstico pós-build para verificar se o JAR foi criado
    - bash: |
        echo "Verificando o conteúdo da pasta target:"
        ls -la target/
        echo "Verificando tamanho do arquivo JAR (se existir):"
        find target -name "*.jar" -exec ls -lh {} \;
      displayName: 'Diagnóstico pós-build'
      
    - task: CopyFiles@2
      displayName: 'Copiar a aplicação OdontofastPipeline'
      inputs:
        SourceFolder: '$(system.defaultworkingdirectory)/target'
        Contents: '*.jar'
        TargetFolder: '$(build.artifactstagingdirectory)'
        flattenFolders: true
      
    # Diagnóstico para verificar os arquivos copiados
    - bash: |
        echo "Verificando arquivos copiados para o staging directory:"
        ls -la $(build.artifactstagingdirectory)
      displayName: 'Verificar arquivos copiados'
      
    - task: PublishBuildArtifacts@1
      displayName: 'Publicar artefato do Build OdontofastPipeline'
      inputs:
        PathtoPublish: '$(build.artifactstagingdirectory)'
        ArtifactName: $(nome-artefato)
        publishLocation: 'Container'
 
# Estágio 3: Deploy da aplicação no Azure App Service
- stage: DeployApp
  jobs:
  - job: DeployWebApp
    displayName: Deploy no Serviço de Aplicativo
    steps:
    - task: DownloadBuildArtifacts@1
      displayName: 'Baixar artefato gerado'
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: '$(nome-artefato)'
        downloadPath: '$(System.DefaultWorkingDirectory)'
        
    # Diagnóstico para verificar os arquivos baixados
    - bash: |
        echo "Verificando arquivos baixados:"
        ls -la $(System.DefaultWorkingDirectory)/$(nome-artefato)
        echo "Procurando arquivos JAR:"
        find $(System.DefaultWorkingDirectory) -name "*.jar"
      displayName: 'Verificar arquivos baixados'
        
    - task: AzureWebApp@1
      displayName: 'Deploy OdontofastPipeline'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        appType: 'webAppLinux'
        appName: $(app-name)
        package: '$(System.DefaultWorkingDirectory)/$(nome-artefato)/*.jar'
        runtimeStack: 'JAVA|17-java17'
        startUpCommand: 'java -jar *.jar'
        
    - task: AzureCLI@2
      displayName: 'Configurar Banco de Dados SQL Server'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Configurando variáveis de ambiente para o App Service..."
          az webapp config appsettings set --resource-group $(resourceGroup) --name $(app-name) --settings \
            SPRING_DATASOURCE_URL="jdbc:sqlserver://$(sql-server-name).database.windows.net:1433;database=$(sql-db-name);encrypt=true;trustServerCertificate=false;hostNameInCertificate=*.database.windows.net;loginTimeout=30;" \
            SPRING_DATASOURCE_USERNAME="$(sql-admin-user)" \
            SPRING_DATASOURCE_PASSWORD="$(sql-admin-password)" \
            SPRING_DATASOURCE_DRIVER_CLASS_NAME="com.microsoft.sqlserver.jdbc.SQLServerDriver" \
            SPRING_JPA_DATABASE_PLATFORM="org.hibernate.dialect.SQLServerDialect" \
            SPRING_JPA_HIBERNATE_DDL_AUTO="update" \
            SPRING_JPA_PROPERTIES_HIBERNATE_FORMAT_SQL="true" \
            SPRING_JPA_SHOW_SQL="true" \
            JAVA_OPTS="-Dserver.port=80 -Xms512m -Xmx1024m"
            
    - task: AzureCLI@2
      displayName: 'Reiniciar aplicação após configuração'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Reiniciando a aplicação..."
          az webapp restart -g $(resourceGroup) -n $(app-name)
          echo "Aguardando inicialização da aplicação..."
          sleep 30
          echo "Exibindo URL da aplicação:"
          echo "https://$(app-name).azurewebsites.net"
          
    - task: AzureCLI@2
      displayName: 'Verificar logs para diagnóstico'
      inputs:
        azureSubscription: 'MyAzureSubscription'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          echo "Exibindo logs da aplicação para diagnóstico de conexão..."
          az webapp log tail -g $(resourceGroup) -n $(app-name) --timeout 60